========= Issues identified ==========

1) The Person and Address entities did not define primary keys, which prevented Hibernate from managing them and stopped the application from starting correctly.

2) The project lacked a database driver and datasource configuration, so Spring Boot could not create a working DataSource.

3) The /api/persons-with-addresses endpoint relied on lazy loading, causing an N+1 query pattern for addresses and returning a large JSON payload in a single response.

========== Changes made (and rationale) ===========

1) Added @Id and @GeneratedValue to both Person and Address so they are valid JPA entities and the application can start and persist data reliably.

2) Introduced an H2 in‑memory database and configured spring.datasource.* and spring.jpa.* properties to keep the project self‑contained and easy to run.

3) Created DTOs (PersonDto, AddressDto, PersonWithAddressesDto) and updated the controllers to return DTOs instead of entities, keeping the external API simple and avoiding exposing internal persistence details.

4) Implemented a seeding endpoint (POST /api/seed/people) that inserts 10,000 persons with 2 addresses each using batched saves, providing a consistent dataset for testing and performance measurements.

=========== Performance improvement approach and impact ===========

1)Replaced the N+1 loading pattern with a single LEFT JOIN FETCH query in PersonRepository.findAllWithAddresses, so persons and their addresses are fetched in one join query instead of many individual address queries.

Measured the endpoints before optimization:

**** GET /api/persons → time_total ≈ 0.861781 **** 

**** GET /api/persons-with-addresses → time_total ≈ 0.885369 **** 

Measured again after the optimizations (join‑fetch, DTO mapping, and related fixes):

****  GET /api/persons → time_total ≈ 0.142674 **** 

**** GET /api/persons-with-addresses → time_total ≈ 0.489564 **** 

These results show a substantial reduction in latency for both endpoints, with /api/persons improving by roughly a factor of six and /api/persons-with-addresses nearly halving in total time, while still returning the same logical data and supporting API‑level pagination when needed.